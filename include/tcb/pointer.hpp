
/*
Copyright (c) 2025 Tristan Brindle (tcbrindle at gmail dot com)

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

#ifndef TCB_PTR_HPP_INCLUDED
#define TCB_PTR_HPP_INCLUDED

#ifdef TCB_PTR_CONFIG_HEADER
#    include TCB_PTR_CONFIG_HEADER
#endif

#ifdef TCB_PTR_BUILDING_MODULE
#    define TCB_PTR_EXPORT export
#else
#    define TCB_PTR_EXPORT
#    include <algorithm> // for std::ranges::equal, std::lexicographical_compare_three_way
#    include <compare> // for std::strong_ordering
#    include <concepts>
#    include <cstddef>
#    include <functional> // for std::invoke
#    include <memory> // for std::addressof
#    include <optional> // for std::optional<pointer>
#    include <ranges> // for std::ranges::contiguous_range etc
#    include <stdexcept> // for std::out_of_range
#    include <typeinfo>
#    include <type_traits>

#    ifndef NDEBUG
#        include <cstdio>
#        include <exception>
#    endif

#    ifdef _MSC_VER
#        include <intrin.h> // for __fastfail
#    endif
#endif // TCB_PTR_BUILDING_MODULE

#if __has_cpp_attribute(clang::lifetimebound)
#    define TCB_PTR_LIFETIME_BOUND [[clang::lifetimebound]]
#elif __has_cpp_attribute(msvc::lifetimebound)
#    define TCB_PTR_LIFETIME_BOUND [[msvc::lifetimebound]]
#else
#    define TCB_PTR_LIFETIME_BOUND
#endif

#if __has_cpp_attribute(gsl::Pointer)
#    define TCB_PTR_GSL_POINTER(T) [[gsl::Pointer(T)]]
#else
#    define TCB_PTR_GSL_POINTER(T)
#endif

#ifndef TCB_PTR_RUNTIME_ERROR
#    ifndef NDEBUG
#        define TCB_PTR_RUNTIME_ERROR(msg)                                                 \
            do {                                                                           \
                std::fprintf(stderr, "%s:%u: Fatal error: %s\n", __FILE__, __LINE__, msg); \
                std::terminate();                                                          \
            } while (0)
#    else
#        if defined(__has_builtin)
#            if __has_builtin(__builtin_trap)
#                define TCB_PTR_RUNTIME_ERROR(msg) __builtin_trap()
#            endif
#        elif defined(_MSC_VER)
#            define TCB_PTR_RUNTIME_ERROR(msg) __fastfail(7) // FAST_FAIL_FATAL_APP_EXIT
#        else
#            define TCB_PTR_RUNTIME_ERROR(msg) std::abort()
#        endif
#    endif // NDEBUG
#endif // TCB_PTR_RUNTIME_ERROR

#if !defined(TCB_PTR_NO_RTTI) && defined(__cpp_rtti)
#    define TCB_PTR_RTTI_ENABLED 1
#else
#    define TCB_PTR_RTTI_ENABLED 0
#endif

#if !defined(TCB_PTR_NO_EXCEPTIONS) && defined(__cpp_exceptions)
#    define TCB_PTR_THROW(ex) throw ex
#else
#    define TCB_PTR_THROW(ex) TCB_PTR_RUNTIME_ERROR(ex.what())
#endif

namespace tcb {

// MARK: Object pointer

TCB_PTR_EXPORT template <typename>
struct pointer;

template <typename T>
    requires(std::is_object_v<T> && !std::is_unbounded_array_v<T>)
struct TCB_PTR_GSL_POINTER(T) pointer<T> {
private:
    T* addr_;

    friend class std::optional<pointer<T>>;

    constexpr explicit pointer(T* addr TCB_PTR_LIFETIME_BOUND) noexcept : addr_(addr) { }

public:
    using element_type = T;

    template <typename U>
        requires std::convertible_to<U*, T*>
    static constexpr auto pointer_to(U& obj TCB_PTR_LIFETIME_BOUND) noexcept -> pointer
    {
        return pointer(std::addressof(obj));
    }

    template <typename U>
        requires std::convertible_to<U*, T*>
    static constexpr auto from_address(U* addr TCB_PTR_LIFETIME_BOUND) -> pointer
    {
        if (!addr) {
            TCB_PTR_RUNTIME_ERROR("Null passed to from_address()");
        }
        return pointer(addr);
    }

    template <typename U>
        requires requires {
            { pointer<U>::pointer_to(*addr_) };
        }
    constexpr operator pointer<U>() const noexcept
    {
        return pointer<U>::pointer_to(*addr_);
    }

    constexpr explicit operator T*() const noexcept { return addr_; }

    constexpr explicit operator bool() const noexcept { return addr_ != nullptr; }

#ifdef __cpp_multidimensional_subscript
    constexpr auto operator[]() const noexcept -> T& { return *addr_; }
#endif

    constexpr auto to_address() const noexcept -> T* { return addr_; }

    constexpr auto operator*() const noexcept -> T& { return *addr_; }

    constexpr auto operator->() const noexcept -> T* { return addr_; }

    friend constexpr auto operator==(pointer lhs, pointer rhs) -> bool
    {
        return lhs.addr_ == rhs.addr_;
    }

    friend constexpr auto operator<=>(pointer lhs, pointer rhs) -> std::strong_ordering
    {
        return std::compare_three_way{}(lhs.addr_, rhs.addr_);
    }
};

// MARK: Void pointer

namespace detail {

#if TCB_PTR_RTTI_ENABLED
template <typename V>
struct void_pointer_base {
    V* addr_ = nullptr;
    std::type_info const* type_ = nullptr;

    template <typename U>
    void_pointer_base(U* addr) : addr_(addr), type_(&typeid(U))
    {
    }
};
#else
template <typename V>
struct void_pointer_base {
    V* addr_ = nullptr;

    template <typename U>
    void_pointer_base(U* addr) : addr_(addr)
    {
    }
};
#endif

} // namespace detail

template <typename V>
    requires std::is_void_v<V>
struct TCB_PTR_GSL_POINTER(V) pointer<V> : detail::void_pointer_base<V> {
private:
    explicit pointer(std::nullptr_t) : detail::void_pointer_base<V>((V*)nullptr) { }

    template <typename U>
        requires std::convertible_to<U*, V*>
    explicit pointer(U* addr TCB_PTR_LIFETIME_BOUND) : detail::void_pointer_base<V>(addr)
    {
    }

    friend class std::optional<pointer<V>>;

public:
    using element_type = V;

    template <typename U>
        requires std::convertible_to<U*, V*>
    static auto pointer_to(U& obj TCB_PTR_LIFETIME_BOUND) -> pointer
    {
        return pointer(std::addressof(obj));
    }

    template <typename U>
        requires std::convertible_to<U*, V*>
    static constexpr auto from_address(U* addr TCB_PTR_LIFETIME_BOUND) -> pointer
    {
        if (!addr) {
            TCB_PTR_RUNTIME_ERROR("Null passed to pointer::from_address()");
        }
        return pointer(addr);
    }

    auto to_address() const -> V* { return this->addr_; }

    auto operator->() const -> V* { return this->addr_; }

#if TCB_PTR_RTTI_ENABLED
    auto type() const -> std::type_info const& { return *this->type_; }
#endif

    explicit operator V*() const { return this->addr_; }

    template <typename U>
        requires(std::is_object_v<U> && !std::is_unbounded_array_v<U> &&
                requires(V* addr) {
                    { static_cast<U*>(addr) };
                })
    explicit operator pointer<U>() const
    {
#if TCB_PTR_RTTI_ENABLED
        if (type() != typeid(void) && type() != typeid(U)) {
            TCB_PTR_RUNTIME_ERROR("Type mismatch in conversion from void pointer");
        }
#endif
        return pointer<U>::pointer_to(*static_cast<U*>(this->addr_));
    }

    template <typename U>
        requires std::is_object_v<U> && requires(V* addr) {
            { static_cast<U*>(addr) };
        }
    explicit operator U*() const
    {
#if TCB_PTR_RTTI_ENABLED
        if (type() != typeid(void) && type() != typeid(U)) {
            TCB_PTR_RUNTIME_ERROR("Type mismatch in conversion from void pointer");
        }
#endif
        return static_cast<U*>(this->addr_);
    }

    explicit operator bool() const noexcept { return this->addr_ != nullptr; }

    friend auto operator==(pointer lhs, pointer rhs) -> bool { return lhs.addr_ == rhs.addr_; }

    friend auto operator<=>(pointer lhs, pointer rhs) -> std::strong_ordering
    {
        return std::compare_three_way{}(lhs.addr_, rhs.addr_);
    }
};

// MARK: Checked iterator

namespace detail {

template <typename T>
struct TCB_PTR_GSL_POINTER(T) checked_iterator {
private:
    T* start_ = nullptr;
    std::ptrdiff_t pos_ = 0;
    std::ptrdiff_t size_ = 0;

    friend struct checked_iterator<std::add_const_t<T>>;

public:
    using value_type = T;
    using reference = value_type&;
    using difference_type = std::ptrdiff_t;
    using iterator_category = std::contiguous_iterator_tag;

    checked_iterator() = default;

    constexpr explicit checked_iterator(T* start, std::ptrdiff_t pos, std::ptrdiff_t size)
        : start_(start), pos_(pos), size_(size)
    {
        if (pos_ < 0 || pos_ > size_) {
            TCB_PTR_RUNTIME_ERROR("Bad size or position in checked_iterator ctor");
        }
    }

    constexpr checked_iterator(checked_iterator<std::remove_const_t<T>> const& other)
        requires(std::is_const_v<T>)
        : start_(other.start_), pos_(other.pos_), size_(other.size_)
    {
    }

    checked_iterator(checked_iterator const&) = default;
    checked_iterator(checked_iterator&&) = default;
    auto operator=(checked_iterator const&) -> checked_iterator& = default;
    auto operator=(checked_iterator&&) -> checked_iterator& = default;
    ~checked_iterator() = default;

    constexpr auto operator*() const -> reference
    {
        if (pos_ == size_) {
            TCB_PTR_RUNTIME_ERROR("Cannot dereference past-the-end iterator");
        }
        return start_[pos_];
    }

    constexpr auto operator[](difference_type idx) const -> reference
    {
        if (idx >= (size_ - pos_) || idx < -pos_) {
            TCB_PTR_RUNTIME_ERROR("Out of bounds random-access read");
        }
        return start_[pos_ + idx];
    }

    constexpr auto operator->() const -> T* { return start_ + pos_; }

    constexpr auto operator++() -> checked_iterator&
    {
        if (pos_ == size_) {
            TCB_PTR_RUNTIME_ERROR("Cannot increment past-the-end iterator");
        }
        ++pos_;
        return *this;
    }

    constexpr auto operator++(int) -> checked_iterator
    {
        auto temp = *this;
        ++*this;
        return temp;
    }

    constexpr auto operator--() -> checked_iterator&
    {
        if (pos_ == 0) {
            TCB_PTR_RUNTIME_ERROR("Cannot decrement start iterator");
        }
        --pos_;
        return *this;
    }

    constexpr auto operator--(int) -> checked_iterator
    {
        auto temp = *this;
        --*this;
        return temp;
    }

    constexpr auto operator+=(difference_type offset) -> checked_iterator&
    {
        if (offset > (size_ - pos_) || offset < -pos_) {
            TCB_PTR_RUNTIME_ERROR("Out of bounds random-access jump");
        }
        pos_ += offset;
        return *this;
    }

    constexpr auto operator-=(difference_type offset) -> checked_iterator&
    {
        if (offset < (pos_ - size_) || offset > pos_) {
            TCB_PTR_RUNTIME_ERROR("Out of bounds random-access jump");
        }
        pos_ -= offset;
        return *this;
    }

    friend constexpr auto operator+(checked_iterator lhs, difference_type rhs) -> checked_iterator
    {
        return lhs += rhs;
    }

    friend constexpr auto operator+(difference_type lhs, checked_iterator rhs) -> checked_iterator
    {
        return rhs += lhs;
    }

    friend constexpr auto operator-(checked_iterator lhs, difference_type rhs) -> checked_iterator
    {
        return lhs -= rhs;
    }

    friend constexpr auto operator-(checked_iterator lhs, checked_iterator rhs) -> difference_type
    {
        return lhs.pos_ - rhs.pos_;
    }

    friend auto operator==(checked_iterator, checked_iterator) -> bool = default;
    friend auto operator<=>(checked_iterator, checked_iterator) -> std::strong_ordering = default;
};

#ifndef TCB_PTR_USE_UNCHECKED_ITERATORS
template <typename T>
using contiguous_iterator_t = checked_iterator<T>;
#else
template <typename T>
using contiguous_iterator_t = T*;
#endif

template <typename T>
constexpr auto make_begin_iterator(T* addr, std::size_t size [[maybe_unused]])
    -> contiguous_iterator_t<T>
{
#ifndef TCB_PTR_USE_UNCHECKED_ITERATORS
    return checked_iterator<T>(addr, 0, static_cast<std::ptrdiff_t>(size));
#else
    return addr;
#endif
}

template <typename T>
constexpr auto make_end_iterator(T* addr, std::size_t size) -> contiguous_iterator_t<T>
{
#ifndef TCB_PTR_USE_UNCHECKED_ITERATORS
    return checked_iterator<T>(addr, static_cast<std::ptrdiff_t>(size),
                               static_cast<std::ptrdiff_t>(size));
#else
    return addr + size;
#endif
}

} // namespace detail

// MARK: Slice

TCB_PTR_EXPORT template <typename T>
    requires(std::is_object_v<T> && !std::is_const_v<T>)
struct TCB_PTR_GSL_POINTER(T) slice {
private:
    T* addr_;
    std::size_t sz_;

    friend struct pointer<T[]>;
    friend struct pointer<T const[]>;

    constexpr explicit slice(T* addr, std::size_t sz) : addr_(addr), sz_(sz) { }

public:
    using value_type = T;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using reference = T&;
    using const_reference = T const&;
    using pointer = value_type*;
    using const_pointer = value_type const*;
    using iterator = detail::contiguous_iterator_t<value_type>;
    using const_iterator = detail::contiguous_iterator_t<value_type const>;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    slice(slice const&) = delete;
    void operator=(slice const&) = delete;

    constexpr auto operator[](size_type idx) -> reference
    {
        if (idx >= sz_) {
            TCB_PTR_RUNTIME_ERROR("Index out of bounds in slice access");
        }
        return addr_[idx];
    }

    constexpr auto operator[](size_type idx) const -> const_reference
    {
        if (idx >= sz_) {
            TCB_PTR_RUNTIME_ERROR("Index out of bounds in slice access");
        }
        return addr_[idx];
    }

    constexpr auto at(size_type idx) -> reference
    {
        if (idx >= sz_) {
            TCB_PTR_THROW(std::out_of_range("Index out of bounds in slice access"));
        }
        return addr_[idx];
    }

    constexpr auto at(size_type idx) const -> const_reference
    {
        if (idx >= sz_) {
            TCB_PTR_THROW(std::out_of_range("Index out of bounds in slice access"));
        }
        return addr_[idx];
    }

    constexpr auto front() -> reference
    {
        if (sz_ == 0) {
            TCB_PTR_RUNTIME_ERROR("Accessing front of empty slice");
        }
        return addr_[0];
    }

    constexpr auto front() const -> const_reference
    {
        if (sz_ == 0) {
            TCB_PTR_RUNTIME_ERROR("Accessing front of empty slice");
        }
        return addr_[0];
    }

    constexpr auto back() -> reference
    {
        if (sz_ == 0) {
            TCB_PTR_RUNTIME_ERROR("Accessing back of empty slice");
        }
        return addr_[sz_ - 1];
    }

    constexpr auto back() const -> const_reference
    {
        if (sz_ == 0) {
            TCB_PTR_RUNTIME_ERROR("Accessing back of empty slice");
        }
        return addr_[sz_ - 1];
    }

    constexpr auto size() const -> size_type { return sz_; }
    constexpr auto empty() const -> bool { return sz_ == 0; }

    constexpr auto data() -> pointer { return addr_; }
    constexpr auto data() const -> const_pointer { return addr_; }

    constexpr auto begin() -> iterator { return detail::make_begin_iterator(addr_, sz_); }
    constexpr auto begin() const -> const_iterator
    {
        return detail::make_begin_iterator(addr_, sz_);
    }
    constexpr auto cbegin() const -> const_iterator { return begin(); }

    constexpr auto end() -> iterator { return detail::make_end_iterator(addr_, sz_); }
    constexpr auto end() const -> const_iterator { return detail::make_end_iterator(addr_, sz_); }
    constexpr auto cend() const -> const_iterator { return end(); }

    constexpr auto rbegin() -> reverse_iterator { return reverse_iterator(end()); }
    constexpr auto rbegin() const -> const_reverse_iterator
    {
        return const_reverse_iterator(end());
    }
    constexpr auto crbegin() const -> const_reverse_iterator { return rbegin(); }

    constexpr auto rend() -> reverse_iterator { return reverse_iterator(begin()); }
    constexpr auto rend() const -> const_reverse_iterator
    {
        return const_reverse_iterator(begin());
    }
    constexpr auto crend() const -> const_reverse_iterator { return rend(); }

    friend constexpr auto operator==(slice const& lhs, slice const& rhs) -> bool
        requires std::equality_comparable<T>
    {
        return std::ranges::equal(lhs, rhs);
    }

    friend constexpr auto operator<=>(slice const& lhs, slice const& rhs)
        requires std::totally_ordered<T>
    {
        auto cmp = [](const_reference lhs, const_reference rhs) {
            if constexpr (std::three_way_comparable<T>) {
                return lhs <=> rhs;
            } else {
                if (lhs < rhs) {
                    return std::weak_ordering::less;
                } else if (rhs < lhs) {
                    return std::weak_ordering::greater;
                } else {
                    return std::weak_ordering::equivalent;
                }
            }
        };
        return std::lexicographical_compare_three_way(lhs.begin(), lhs.end(), rhs.begin(),
                                                      rhs.end(), cmp);
    }
};

// MARK: Array pointer

namespace detail {

template <typename R>
concept pointer_compatible_range = std::ranges::borrowed_range<R>
    && std::ranges::contiguous_range<R> && std::ranges::sized_range<R>;

} // namespace detail

template <typename T>
    requires std::is_object_v<T>
struct TCB_PTR_GSL_POINTER(T) pointer<T[]> {
private:
    using slice_type = slice<std::remove_const_t<T>>;
    mutable slice_type slice_ = slice_type(nullptr, 0);

    friend class std::optional<pointer<T[]>>;

    // Secret nullptr constructor for use by optional
    constexpr pointer(std::nullptr_t) noexcept { }

    constexpr explicit pointer(T* ptr, std::size_t sz)
        : slice_(const_cast<std::remove_const_t<T>*>(ptr), sz)
    {
    }

public:
    using element_type = std::conditional_t<std::is_const_v<T>, slice_type const, slice_type>;

    template <detail::pointer_compatible_range R>
        requires std::convertible_to<
            std::remove_reference_t<std::ranges::range_reference_t<R>> (*)[], T (*)[]>
    static constexpr auto pointer_to(R&& rng) -> pointer
    {
        return pointer(std::ranges::data(rng), std::ranges::size(rng));
    }

    template <typename U>
        requires std::convertible_to<U (*)[], T (*)[]>
    static constexpr auto from_address_with_size(U* ptr TCB_PTR_LIFETIME_BOUND, std::size_t sz)
        -> pointer
    {
        if (ptr == nullptr) {
            TCB_PTR_RUNTIME_ERROR("Null pointer passed to from_address_with_size()");
        }
        return pointer(ptr, sz);
    }

    constexpr pointer(pointer const& other) noexcept : slice_(other.slice_.addr_, other.slice_.sz_)
    {
    }

    // If we are const, allow copy-construction from non-const
    constexpr pointer(pointer<std::remove_const_t<T>[]> const& other) noexcept
        requires std::is_const_v<T>
        : slice_(other->data(), other->size())
    {
    }

    constexpr auto operator=(pointer const& other) noexcept -> pointer&
    {
        slice_.addr_ = other.slice_.addr_;
        slice_.sz_ = other.slice_.sz_;
        return *this;
    }

    constexpr auto operator*() const& noexcept TCB_PTR_LIFETIME_BOUND->element_type&
    {
        return slice_;
    }
    void operator*() const&& = delete;

#ifdef __cpp_multidimensional_subscript
    constexpr auto operator[]() const& noexcept TCB_PTR_LIFETIME_BOUND->element_type&
    {
        return slice_;
    }
    void operator[]() const&& = delete;
#endif

    constexpr auto operator->() const& noexcept TCB_PTR_LIFETIME_BOUND->element_type*
    {
        return std::addressof(slice_);
    }
    void operator->() const&& = delete;

    constexpr explicit operator bool() const noexcept { return slice_.addr_ != nullptr; }

    friend constexpr auto operator==(pointer const& lhs, pointer const& rhs) -> bool
    {
        return lhs->data() == rhs->data() && lhs->size() == rhs->size();
    }

    friend constexpr auto operator<=>(pointer const& lhs, pointer const& rhs)
        -> std::strong_ordering
    {
        auto cmp = std::compare_three_way{}(lhs->data(), rhs->data());
        return cmp == 0 ? lhs->size() <=> rhs->size() : cmp;
    }
};

TCB_PTR_EXPORT template <typename T>
using array_pointer = pointer<T[]>;

// MARK: Functions

TCB_PTR_EXPORT
struct pointer_to_t {
    template <typename T>
    constexpr auto operator()(T const& obj TCB_PTR_LIFETIME_BOUND) const -> pointer<T const>
    {
        return pointer<T const>::pointer_to(obj);
    }

    template <typename T>
    void operator()(T const&&) const = delete;
};

TCB_PTR_EXPORT
struct pointer_to_mut_t {
    template <typename T>
        requires(!std::is_const_v<T>)
    constexpr auto operator()(T& obj TCB_PTR_LIFETIME_BOUND) const -> pointer<T>
    {
        return pointer<T>::pointer_to(obj);
    }
};

TCB_PTR_EXPORT
struct pointer_to_array_t {
    template <typename R>
        requires detail::pointer_compatible_range<R>
    constexpr auto operator()(R&& arr) const
        -> pointer<std::add_const_t<std::remove_reference_t<std::ranges::range_reference_t<R>>>[]>
    {
        return pointer<std::add_const_t<
            std::remove_reference_t<std::ranges::range_reference_t<R>>>[]>::pointer_to(arr);
    }
};

TCB_PTR_EXPORT
struct pointer_to_mut_array_t {
    template <typename R>
        requires detail::pointer_compatible_range<R>
        && (!std::is_const_v<std::remove_reference_t<std::ranges::range_reference_t<R>>>)
    constexpr auto operator()(R&& arr) const
        -> pointer<std::remove_reference_t<std::ranges::range_reference_t<R>>[]>
    {
        return pointer<std::remove_reference_t<std::ranges::range_reference_t<R>>[]>::pointer_to(
            arr);
    }
};

TCB_PTR_EXPORT
struct to_address_t {
    template <typename T>
    constexpr auto operator()(pointer<T> ptr) const noexcept -> typename pointer<T>::element_type*
    {
        return ptr.operator->();
    }
};

TCB_PTR_EXPORT template <typename To>
struct static_pointer_cast_t {
    template <typename From>
        requires requires(From* from) {
            { static_cast<To*>(from) };
        }
    constexpr auto operator()(pointer<From> ptr) const noexcept -> pointer<To>
    {
        if constexpr (std::is_unbounded_array_v<To>) {
            static_assert(std::is_unbounded_array_v<From>);
            return pointer<To>::from_address_with_size(
                static_cast<std::remove_extent_t<To>*>(ptr->data()), ptr->size());
        } else {
            return pointer<To>::from_address(static_cast<To*>(ptr.to_address()));
        }
    }
};

TCB_PTR_EXPORT template <typename To>
struct const_pointer_cast_t {
    template <typename From>
        requires requires(From* from) {
            { const_cast<To*>(from) };
        }
    constexpr auto operator()(pointer<From> ptr) const noexcept -> pointer<To>
    {
        if constexpr (std::is_unbounded_array_v<To>) {
            static_assert(std::is_unbounded_array_v<From>);
            return pointer<To>::from_address_with_size(
                const_cast<std::remove_extent_t<To>*>(ptr->data()), ptr->size());
        } else {
            return pointer<To>::from_address(const_cast<To*>(ptr.to_address()));
        }
    }
};

TCB_PTR_EXPORT template <typename Derived>
struct dynamic_pointer_cast_t {
    template <typename Base>
        requires requires(Base* base) {
            { dynamic_cast<Derived*>(base) };
        }
    constexpr auto operator()(pointer<Base> ptr) const noexcept -> std::optional<pointer<Derived>>
    {
        Derived* addr = dynamic_cast<Derived*>(ptr.to_address());
        if (addr) {
            return pointer<Derived>::from_address(addr);
        } else {
            return {};
        }
    }
};

TCB_PTR_EXPORT inline constexpr auto pointer_to = pointer_to_t{};
TCB_PTR_EXPORT inline constexpr auto pointer_to_mut = pointer_to_mut_t{};
TCB_PTR_EXPORT inline constexpr auto pointer_to_array = pointer_to_array_t{};
TCB_PTR_EXPORT inline constexpr auto pointer_to_mut_array = pointer_to_mut_array_t{};
TCB_PTR_EXPORT inline constexpr auto to_address = to_address_t{};

TCB_PTR_EXPORT template <typename To>
inline constexpr auto static_pointer_cast = static_pointer_cast_t<To>{};

TCB_PTR_EXPORT template <typename To>
inline constexpr auto const_pointer_cast = const_pointer_cast_t<To>{};

TCB_PTR_EXPORT template <typename Derived>
inline constexpr auto dynamic_pointer_cast = dynamic_pointer_cast_t<Derived>{};

// Slightly shortened aliases
TCB_PTR_EXPORT template <typename T>
using ptr = pointer<T>;

TCB_PTR_EXPORT template <typename T>
using array_ptr = pointer<T[]>;

TCB_PTR_EXPORT inline constexpr auto& ptr_to = pointer_to;
TCB_PTR_EXPORT inline constexpr auto& ptr_to_mut = pointer_to_mut;
TCB_PTR_EXPORT inline constexpr auto& ptr_to_array = pointer_to_array;
TCB_PTR_EXPORT inline constexpr auto& ptr_to_mut_array = pointer_to_mut_array;

} // namespace tcb

template <typename T>
constexpr bool std::ranges::enable_borrowed_range<tcb::slice<T>> = true;

namespace std {

// MARK: std::hash

template <typename T>
struct hash<tcb::pointer<T>> {
    auto operator()(tcb::pointer<T> ptr) const noexcept -> size_t
    {
        if constexpr (is_unbounded_array_v<T>) {
            auto hasher = hash<remove_extent_t<T>*>{};
            auto h1 = hasher(ptr->data());
            auto h2 = hasher(ptr->data() + ptr->size());
            // Taken from boost::hash_combine
            h1 ^= h2 + 0x9e3779b9 + (h1 << 6) + (h1 >> 2);
            return h1;
        } else {
            return hash<T*>()(to_address(ptr));
        }
    }
};

// MARK: std::optional

template <typename T>
class optional<tcb::pointer<T>> {
private:
    tcb::pointer<T> ptr_;

public:
    using value_type = tcb::pointer<T>;
    using iterator = tcb::detail::contiguous_iterator_t<value_type>;
    using const_iterator = tcb::detail::contiguous_iterator_t<value_type const>;

    /*
     * Constructors
     */

    constexpr optional() noexcept : ptr_(nullptr) { }

    constexpr optional(nullopt_t) noexcept : ptr_(nullptr) { }

    optional(optional const&) = default;

    optional(optional&&) = default;

    template <typename U>
        requires(is_constructible_v<tcb::pointer<T>, U const&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U>&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U> const&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U> &&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U> const &&>
                 && !is_convertible_v<optional<U>&, tcb::pointer<T>>
                 && !is_convertible_v<optional<U> const&, tcb::pointer<T>>
                 && !is_convertible_v<optional<U> &&, tcb::pointer<T>>
                 && !is_convertible_v<optional<U> const &&, tcb::pointer<T>>)
    constexpr explicit(!is_convertible_v<const U&, tcb::pointer<T>>) optional(
        optional<U> const& other) noexcept(is_nothrow_constructible_v<tcb::pointer<T>, U const&>)
        : ptr_(other ? *other : tcb::pointer<T>(nullptr))
    {
    }

    template <typename U>
        requires(is_constructible_v<tcb::pointer<T>, U>
                 && !is_constructible_v<tcb::pointer<T>, optional<U>&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U> const&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U> &&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U> const &&>
                 && !is_convertible_v<optional<U>&, tcb::pointer<T>>
                 && !is_convertible_v<optional<U> const&, tcb::pointer<T>>
                 && !is_convertible_v<optional<U> &&, tcb::pointer<T>>
                 && !is_convertible_v<optional<U> const &&, tcb::pointer<T>>)
    constexpr explicit(!is_convertible_v<U, tcb::pointer<T>>)
        optional(optional<U>&& other) noexcept(is_nothrow_constructible_v<tcb::pointer<T>, U>)
        : ptr_(other ? std::move(*other) : tcb::pointer<T>(nullptr))
    {
    }

    template <typename... Args>
        requires constructible_from<tcb::pointer<T>, Args...>
    constexpr explicit optional(in_place_t, Args&&... args) noexcept(
        std::is_nothrow_constructible_v<tcb::pointer<T>, Args...>)
        : ptr_(static_cast<Args&&>(args)...)
    {
    }

    // (skip init-list constructor, it will never be valid)

    template <typename U = tcb::pointer<T>>
        requires is_constructible_v<tcb::pointer<T>, U>
        && (!same_as<remove_cvref_t<U>, in_place_t> && !same_as<remove_cvref_t<U>, optional>)
    constexpr explicit(!is_convertible_v<U, tcb::pointer<T>>)
        optional(U&& value) noexcept(is_nothrow_constructible_v<tcb::pointer<T>, U>)
        : ptr_(static_cast<U&&>(value))
    {
    }

    ~optional() = default;

    /*
     * Assignment operators
     */
    constexpr auto operator=(nullopt_t) noexcept -> optional&
    {
        ptr_ = tcb::pointer<T>(nullptr);
        return *this;
    }

    auto operator=(optional const&) -> optional& = default;

    auto operator=(optional&&) -> optional& = default;

    template <typename U>
        requires(is_constructible_v<tcb::pointer<T>, U const&>
                 && is_assignable_v<tcb::pointer<T>&, U const&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U>&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U> const&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U> &&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U> const &&>
                 && !is_convertible_v<optional<U>&, tcb::pointer<T>>
                 && !is_convertible_v<optional<U> const&, tcb::pointer<T>>
                 && !is_convertible_v<optional<U> &&, tcb::pointer<T>>
                 && !is_convertible_v<optional<U> const &&, tcb::pointer<T>>
                 && !is_assignable_v<tcb::pointer<T>&, optional<U>&>
                 && !is_assignable_v<tcb::pointer<T>&, optional<U> const&>
                 && !is_assignable_v<tcb::pointer<T>&, optional<U> &&>
                 && !is_assignable_v<tcb::pointer<T>&, optional<U> const &&>)
    constexpr auto operator=(optional<U> const& other) -> optional&
    {
        if (has_value()) {
            if (other.has_value()) {
                ptr_ = *other;
            } else {
                ptr_ = tcb::pointer<T>(nullptr);
            }
        } else {
            if (other.has_value()) {
                ptr_ = tcb::pointer<T>(*other);
            }
        }
        return *this;
    }

    template <typename U>
        requires(is_constructible_v<tcb::pointer<T>, U> && is_assignable_v<tcb::pointer<T>&, U>
                 && !is_constructible_v<tcb::pointer<T>, optional<U>&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U> const&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U> &&>
                 && !is_constructible_v<tcb::pointer<T>, optional<U> const &&>
                 && !is_convertible_v<optional<U>&, tcb::pointer<T>>
                 && !is_convertible_v<optional<U> const&, tcb::pointer<T>>
                 && !is_convertible_v<optional<U> &&, tcb::pointer<T>>
                 && !is_convertible_v<optional<U> const &&, tcb::pointer<T>>
                 && !is_assignable_v<tcb::pointer<T>&, optional<U>&>
                 && !is_assignable_v<tcb::pointer<T>&, optional<U> const&>
                 && !is_assignable_v<tcb::pointer<T>&, optional<U> &&>
                 && !is_assignable_v<tcb::pointer<T>&, optional<U> const &&>)
    constexpr auto operator=(optional<U>&& other) -> optional&
    {
        if (has_value()) {
            if (other.has_value()) {
                ptr_ = std::move(*other);
            } else {
                ptr_ = tcb::pointer<T>(nullptr);
            }
        } else {
            if (other.has_value()) {
                ptr_ = tcb::pointer<T>(std::move(*other));
            }
        }
        return *this;
    }

    template <typename U = tcb::pointer<T>>
        requires(!same_as<remove_cvref_t<U>, optional> && is_constructible_v<tcb::pointer<T>, U>
                 && is_assignable_v<tcb::pointer<T>, U>)
    constexpr auto operator=(U&& value) -> optional&
    {
        if (has_value()) {
            ptr_ = static_cast<U&&>(value);
        } else {
            ptr_ = tcb::pointer<T>(static_cast<U&&>(value));
        }
        return *this;
    }

    /*
     * Iterator support
     */
    constexpr auto begin() noexcept -> iterator
    {
        return tcb::detail::make_begin_iterator(std::addressof(ptr_), has_value() ? 1 : 0);
    }

    constexpr auto begin() const noexcept -> const_iterator
    {
        return tcb::detail::make_begin_iterator(std::addressof(ptr_), has_value() ? 1 : 0);
    }

    constexpr auto end() noexcept -> iterator
    {
        return tcb::detail::make_end_iterator(std::addressof(ptr_), has_value() ? 1 : 0);
    }

    constexpr auto end() const noexcept -> const_iterator
    {
        return tcb::detail::make_end_iterator(std::addressof(ptr_), has_value() ? 1 : 0);
    }

    /*
     * Observers
     */
    constexpr auto operator->() -> tcb::pointer<T>*
    {
        if (!has_value()) {
            TCB_PTR_RUNTIME_ERROR("Accessing member of empty optional");
        }
        return std::addressof(ptr_);
    }

    constexpr auto operator->() const -> tcb::pointer<T> const*
    {
        if (!has_value()) {
            TCB_PTR_RUNTIME_ERROR("Accessing member of empty optional");
        }
        return std::addressof(ptr_);
    }

    constexpr auto operator*() & -> tcb::pointer<T>&
    {
        if (!has_value()) {
            TCB_PTR_RUNTIME_ERROR("Dereferencing empty optional");
        }
        return ptr_;
    }

    constexpr auto operator*() const& -> tcb::pointer<T> const&
    {
        if (!has_value()) {
            TCB_PTR_RUNTIME_ERROR("Dereferencing empty optional");
        }
        return ptr_;
    }

    constexpr auto operator*() && -> tcb::pointer<T>&&
    {
        if (!has_value()) {
            TCB_PTR_RUNTIME_ERROR("Dereferencing empty optional");
        }
        return std::move(ptr_);
    }

    constexpr auto operator*() const&& -> tcb::pointer<T> const&&
    {
        if (!has_value()) {
            TCB_PTR_RUNTIME_ERROR("Dereferencing empty optional");
        }
        return std::move(ptr_);
    }

    constexpr auto has_value() const noexcept -> bool { return static_cast<bool>(ptr_); }
    constexpr explicit operator bool() const noexcept { return has_value(); }

    constexpr auto value() & -> tcb::pointer<T>&
    {
        if (!has_value()) {
            TCB_PTR_THROW(std::bad_optional_access{});
        }
        return ptr_;
    }

    constexpr auto value() const& -> tcb::pointer<T> const&
    {
        if (!has_value()) {
            TCB_PTR_THROW(std::bad_optional_access{});
        }
        return ptr_;
    }

    constexpr auto value() && -> tcb::pointer<T>&&
    {
        if (!has_value()) {
            TCB_PTR_THROW(std::bad_optional_access{});
        }
        return std::move(ptr_);
    }

    constexpr auto value() const&& -> tcb::pointer<T> const&&
    {
        if (!has_value()) {
            TCB_PTR_THROW(std::bad_optional_access{});
        }
        return std::move(ptr_);
    }

    template <typename U = tcb::pointer<T>>
        requires std::is_convertible_v<U&&, tcb::pointer<T>>
    constexpr auto value_or(U&& default_value) const& -> tcb::pointer<T>
    {
        if (has_value()) {
            return ptr_;
        } else {
            return tcb::pointer<T>(static_cast<U&&>(default_value));
        }
    }

    template <typename U = tcb::pointer<T>>
        requires std::is_convertible_v<U&&, tcb::pointer<T>>
    constexpr auto value_or(U&& default_value) && -> tcb::pointer<T>
    {
        if (has_value()) {
            return std::move(ptr_);
        } else {
            return tcb::pointer<T>(static_cast<U&&>(default_value));
        }
    }

    /*
     * Monadic operations
     */
    template <typename F>
        requires invocable<F, tcb::pointer<T>&>
    constexpr auto and_then(F&& f) &
    {
        if (has_value()) {
            return std::invoke(static_cast<F&&>(f), ptr_);
        } else {
            return remove_cvref_t<invoke_result_t<F, tcb::pointer<T>&>>{};
        }
    }

    template <typename F>
        requires invocable<F, tcb::pointer<T> const&>
    constexpr auto and_then(F&& f) const&
    {
        if (has_value()) {
            return std::invoke(static_cast<F&&>(f), ptr_);
        } else {
            return remove_cvref_t<invoke_result_t<F, tcb::pointer<T> const&>>{};
        }
    }

    template <typename F>
        requires invocable<F, tcb::pointer<T>&&>
    constexpr auto and_then(F&& f) &&
    {
        if (has_value()) {
            return std::invoke(static_cast<F&&>(f), std::move(ptr_));
        } else {
            return remove_cvref_t<invoke_result_t<F, tcb::pointer<T>&&>>{};
        }
    }

    template <typename F>
        requires invocable<F, tcb::pointer<T> const&&>
    constexpr auto and_then(F&& f) const&&
    {
        if (has_value()) {
            return std::invoke(static_cast<F&&>(f), std::move(ptr_));
        } else {
            return remove_cvref_t<invoke_result_t<F, tcb::pointer<T> const&&>>{};
        }
    }

    template <typename F, typename U = remove_cvref_t<invoke_result_t<F, tcb::pointer<T>&>>>
        requires(!same_as<U, in_place_t> && !same_as<U, nullopt_t>)
    constexpr auto transform(F&& f) & -> optional<U>
    {
        if (has_value()) {
            return optional<U>(std::invoke(static_cast<F&&>(f), ptr_));
        } else {
            return optional<U>{};
        }
    }

    template <typename F, typename U = remove_cvref_t<invoke_result_t<F, tcb::pointer<T> const&>>>
        requires(!same_as<U, in_place_t> && !same_as<U, nullopt_t>)
    constexpr auto transform(F&& f) const& -> optional<U>
    {
        if (has_value()) {
            return optional<U>(std::invoke(static_cast<F&&>(f), ptr_));
        } else {
            return optional<U>{};
        }
    }

    template <typename F, typename U = remove_cvref_t<invoke_result_t<F, tcb::pointer<T>&&>>>
        requires(!same_as<U, in_place_t> && !same_as<U, nullopt_t>)
    constexpr auto transform(F&& f) && -> optional<U>
    {
        if (has_value()) {
            return optional<U>(std::invoke(static_cast<F&&>(f), std::move(ptr_)));
        } else {
            return optional<U>{};
        }
    }

    template <typename F, typename U = remove_cvref_t<invoke_result_t<F, tcb::pointer<T> const&&>>>
        requires(!same_as<U, in_place_t> && !same_as<U, nullopt_t>)
    constexpr auto transform(F&& f) const&& -> optional<U>
    {
        if (has_value()) {
            return optional<U>(std::invoke(static_cast<F&&>(f), std::move(ptr_)));
        } else {
            return optional<U>{};
        }
    }

    template <typename F>
        requires invocable<F> && same_as<invoke_result_t<F>, optional>
    constexpr auto or_else(F&& f) const& -> optional
    {
        if (has_value()) {
            return *this;
        } else {
            return std::invoke(static_cast<F&&>(f));
        }
    }

    template <typename F>
        requires invocable<F> && same_as<invoke_result_t<F>, optional>
    constexpr auto or_else(F&& f) && -> optional
    {
        if (has_value()) {
            return std::move(*this);
        } else {
            return std::invoke(static_cast<F&&>(f));
        }
    }

    /*
     * Modifiers
     */

    constexpr void swap(optional& other) noexcept { std::swap(ptr_, other.ptr_); }

    constexpr void reset() noexcept { ptr_ = tcb::pointer<T>(nullptr); }

    template <typename... Args>
        requires std::constructible_from<tcb::pointer<T>, Args...>
    constexpr auto emplace(Args&&... args) -> tcb::pointer<T>&
    {
        ptr_ = tcb::pointer<T>(static_cast<Args&&>(args)...);
        return ptr_;
    }

    // skip init-list overload of emplace(), it will never be valid
};

} // namespace std

#endif